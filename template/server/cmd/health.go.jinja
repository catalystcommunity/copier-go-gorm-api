package cmd

import (
	"context"
	"database/sql"
	"io/fs"
	"regexp"
	"strconv"

    "{{ full_project_name }}/server/storage"
	{{ short_project_name }}v1 "{{ full_project_name }}/protos/gen/proto/go/portal/v1"
	"{{ full_project_name }}/server/config"
	"github.com/catalystsquad/app-utils-go/errorutils"
	"github.com/catalystsquad/app-utils-go/logging"
	"github.com/pressly/goose/v3"
	"github.com/sirupsen/logrus"
	"google.golang.org/grpc/health/grpc_health_v1"
)

// exists for side effects, checks implementation at compile time, so compile
// will fail if the interface isn't implemented corectly.
var _ {{ short_project_name }}v1.HealthServiceServer = &HealthServiceServer{}

type HealthServiceServer struct{}

var expectedVersion = getHighestVersionFromEmbeddedMigrations()
var migrationsComplete = false

type HealthChecker struct{}

func (h HealthServiceServer) Health(ctx context.Context, request *{{ short_project_name }}v1.HealthRequest) (*{{ short_project_name }}v1.HealthResponse, error) {
	return &{{ short_project_name }}v1.HealthResponse{Success: migrationsAreComplete()}, nil
}

func (h HealthServiceServer) Config(ctx context.Context, request *{{ short_project_name }}v1.ConfigRequest) (*{{ short_project_name }}v1.ConfigResponse, error) {
	return &{{ short_project_name }}v1.ConfigResponse{
		ThirdPartySyncEnabled: config.SalesforceSyncEnabled,
	}, nil
}

func NewHealthChecker() *HealthChecker {
	return &HealthChecker{}
}

func (s *HealthChecker) Check(ctx context.Context, req *grpc_health_v1.HealthCheckRequest) (*grpc_health_v1.HealthCheckResponse, error) {
	return getHealthCheckResponse()
}

func (s *HealthChecker) Watch(req *grpc_health_v1.HealthCheckRequest, server grpc_health_v1.Health_WatchServer) error {
	response, err := getHealthCheckResponse()
	if err != nil {
		return err
	}
	return server.Send(response)
}

// returns not serving by default, only returns serving if external dependencies like database migrations are finished
func getHealthCheckResponse() (*grpc_health_v1.HealthCheckResponse, error) {
	// default to not serving, which passes a k8s health check, but fails a k8s readiness check
	status := grpc_health_v1.HealthCheckResponse_NOT_SERVING
	if migrationsAreComplete() {
		// migrations complete means we're ready, set to serving to pass readiness check
		status = grpc_health_v1.HealthCheckResponse_SERVING
	}
	return &grpc_health_v1.HealthCheckResponse{
		Status: status,
	}, nil
}

// compares the parsed maximum db migration version against the database's current migration version, returns true
// if they are equal
func migrationsAreComplete() bool {
	if migrationsComplete {
		// immediately return if we know the migrations are complete
		return true
	}
	// connect to the db
	sqldb, err := sql.Open("postgres", config.CockroachdbUri)
	if err != nil {
		errorutils.LogOnErr(nil, "error getting sql db from gorm db", err)
		return false
	}
	defer sqldb.Close()
	// get the current version from the db
	var currentVersion int64
	if currentVersion, err = goose.GetDBVersion(sqldb); err != nil {
		return false
	}
	// set the global migrationsComplete variable for reference for the next health check. This avoids needlessly
	// pinging the db on every health check
	migrationsComplete = expectedVersion == currentVersion
	if !migrationsComplete {
		// log error for visibility on readiness
		logging.Log.WithFields(logrus.Fields{"expected_version": expectedVersion, "current_version": currentVersion}).Error("readiness check failed: database migrations are not complete")
	}
	return migrationsComplete
}

// parses the embedded migrations directory for migration files and returns the highest version number
func getHighestVersionFromEmbeddedMigrations() (highestVersion int64) {
	goose.SetBaseFS(migrations)
	var files []fs.DirEntry
	var err error
	if files, err = migrations.ReadDir("migrations"); err != nil {
		errorutils.LogOnErr(nil, "error reading embedded migrations", err)
		return
	}

	pattern := regexp.MustCompile("(\\d+)")
	for _, file := range files {
		var version int64
		capture := pattern.Find([]byte(file.Name()))
		if version, err = strconv.ParseInt(string(capture), 10, 32); err != nil {
			errorutils.LogOnErr(nil, "error getting migration version from file", err)
			return
		}
		if version > highestVersion {
			highestVersion = version
		}
	}
	return
}